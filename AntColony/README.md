# 蚁群算法

## 基础概念

| 定义                             | 参数影响分析                                                 |
| -------------------------------- | ------------------------------------------------------------ |
| α 信息启发式因子[0,5]            | α 值越大，蚂蚁选择之前走过的路径可能性就越大，搜索路径的随机性减弱，α 越小，蚂蚁群搜索范围就会减少，容易陷入局部最优 |
| β 期望启发式因子[0,5]            | β 值越大，蚂蚁就越容易选择局部较短路径，这时算法的收敛速度是加快了，但是随机性却不高，容易得到局部的相对最优 |
| m 蚁群数量                       | m 数目越多，得到的最优解就越精确，但是会产生不少重复解，随着算法接近最优值的收敛，信息正反馈作用降低，大量的重复工作，消耗了资源，增加了时间复杂度 |
| ρ 信息挥发因子，1-ρ 表示残留因子 | ρ 过小时，在各路径上残留的信息素过多，导致无效的路径继续被搜索，影响到算法的收敛速率；ρ 过大，无效的路径虽然可以被排除搜索，但是不能保证有效的路径也会被放弃搜索，影响到最优值的搜索 |



（1）蚂蚁携带等量的信息素在周游过程中释放
（2）信息素的浓度和路径的长度成反比
（3）蚂蚁利用信息素进行相互通信，下次蚂蚁来到路口会选择信息素浓度较高的那条路
（4）短的路径上的信息素浓度会越来越大，最终成为蚁群的最优路径，即产生最优解

理论上：



信息素更新（信息素强度τ，信息素挥发参数ρ 取值范围：[0.1,0.99]，Q为常数[10,1000]）

为了避免残留信息素过多而淹没启发信息，在每只蚂蚁走完一步或者完成对所有n个城市的遍历（也即一个循环结束）后，要对残留信息进行更新处理。由此，t+n时刻在路径(i,j)上的信息量可按如下规则进行调整：
$$
\tau _{ij}(t+n)=(1-\rho )\cdot \tau _{ij}(t)+\triangle \tau _{ij}(t) 
$$

$$
\triangle \tau _{ij}(t)=\sum _{k=1}^{m}\triangle \tau _{ij}^{k}(t)
$$

 式中：$\rho (0 < \rho < 1)$表示各路径上的信息素蒸发系数，$\Delta \tau_{ij}$  表示在路径 $ij$ 上信息素增量。



（1）开始

（2）建立种群和基本参数设置

（3）开始迭代

（4）产生出发城市

（5）计算城市间的转移概率，根据轮盘赌确定下一个访问的城市

（6）计算各条路径距离

（7）更新信息素

（8）每次迭代记录下最优值

（9） 结束

**概率计算公式**

在蚁群算法中，每只蚂蚁选择下一个城市的概率由信息素浓度和城市间距离决定。具体计算公式如下：

对于每一个未被访问的城市 `i`，其被选择的概率 `select_citys_prob[i]` 计算如下：

$$
prob[i] = \left( \text{pheromone\_graph}[\text{current\_city}][i] \right)^{\alpha} \times \left( \frac{1.0}{\text{distance\_graph}[\text{current\_city}][i]} \right)^{\beta}
$$


参数说明

- `pheromone_graph[current_city][i]`：从当前城市到城市 `i` 的信息素浓度。
- `distance_graph[current_city][i]`：从当前城市到城市 `i` 的距离。
- `\alpha` (ALPHA)：信息素的重要性因子，控制信息素的影响力。
- `\beta` (BETA)：启发因子，控制距离的影响力。



### 轮盘赌

假设有三个候选城市A、B、C，其选择概率分别为0.2、0.5和0.3。总概率为1.0。

​	•	生成一个在0.0到1.0之间的随机数，假设随机数为0.6。

​	•	依次减去城市的选择概率：

​	•	从0.6减去A的选择概率0.2，结果为0.4。

​	•	从0.4减去B的选择概率0.5，结果为-0.1。

​	•	当结果小于0时，选择当前城市B。

当随机数小于0时，表明当前城市的累积概率区间包含该随机数，**因此选择当前城市是合理的。**

转这个盘子，看看这个随机数是不是出现在了这个概率区间上。

```python
# 轮盘选择城市
# 如果总概率大于0
if total_prob > 0.0:
    # 生成一个在0.0到total_prob之间的随机概率
    temp_prob = random.uniform(0.0, total_prob)
    # 遍历所有城市
    for i in range(city_num):
        # 如果城市i还未被访问
        if self.open_table_city[i]:
            # 从临时概率中减去城市i的选择概率
            temp_prob -= select_citys_prob[i]
            # 如果临时概率小于0
            if temp_prob < 0.0:
                # 选择城市i作为下一个城市
                next_city = i
                # 结束循环
                break
```
